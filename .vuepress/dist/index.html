<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>wepy与mpvue对比分析</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="https://shawtung.github.io/mpvue-wepy-compare/assets/css/1.styles.d6a57d9d.css" as="style"><link rel="preload" href="https://shawtung.github.io/mpvue-wepy-compare/assets/js/app.eedcdc70.js" as="script"><link rel="preload" href="https://shawtung.github.io/mpvue-wepy-compare/assets/js/0.e6d0ac29.js" as="script">
    <link rel="stylesheet" href="https://shawtung.github.io/mpvue-wepy-compare/assets/css/1.styles.d6a57d9d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-navbar"><!----><div class="sidebar-mask"></div><div class="sidebar"><!----><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>wepy与mpvue对比分析</span><!----></p><ul class="sidebar-group-items"><li><a href="/https:/shawtung.github.io/mpvue-wepy-compare/#wepy的坑点" class="sidebar-link">wepy的坑点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/https:/shawtung.github.io/mpvue-wepy-compare/#蛋疼的组件体系" class="sidebar-link">蛋疼的组件体系</a></li><li class="sidebar-sub-header"><a href="/https:/shawtung.github.io/mpvue-wepy-compare/#事件体系" class="sidebar-link">事件体系</a></li><li class="sidebar-sub-header"><a href="/https:/shawtung.github.io/mpvue-wepy-compare/#数据绑定" class="sidebar-link">数据绑定</a></li><li class="sidebar-sub-header"><a href="/https:/shawtung.github.io/mpvue-wepy-compare/#问题根源" class="sidebar-link">问题根源</a></li></ul></li><li><a href="/https:/shawtung.github.io/mpvue-wepy-compare/#除以上对比之外mpvue的可赞之处" class="sidebar-link">除以上对比之外mpvue的可赞之处</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/https:/shawtung.github.io/mpvue-wepy-compare/#小程序本身的无法避免的坑点" class="sidebar-link">小程序本身的无法避免的坑点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/https:/shawtung.github.io/mpvue-wepy-compare/#开发者工具" class="sidebar-link">开发者工具</a></li><li class="sidebar-sub-header"><a href="/https:/shawtung.github.io/mpvue-wepy-compare/#明明能做好但就是不做好气死你系列" class="sidebar-link">明明能做好但就是不做好气死你系列</a></li><li class="sidebar-sub-header"><a href="/https:/shawtung.github.io/mpvue-wepy-compare/#跨平台统一性并不完善" class="sidebar-link">跨平台统一性并不完善</a></li><li class="sidebar-sub-header"><a href="/https:/shawtung.github.io/mpvue-wepy-compare/#一些小程序底层的问题" class="sidebar-link">一些小程序底层的问题</a></li></ul></li><li><a href="/https:/shawtung.github.io/mpvue-wepy-compare/#迁移" class="sidebar-link">迁移</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/https:/shawtung.github.io/mpvue-wepy-compare/#迁移工作" class="sidebar-link">迁移工作</a></li><li class="sidebar-sub-header"><a href="/https:/shawtung.github.io/mpvue-wepy-compare/#迁移成本-米奇crm小程序" class="sidebar-link">迁移成本(米奇CRM小程序)</a></li></ul></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="wepy与mpvue对比分析"><a href="#wepy与mpvue对比分析" aria-hidden="true" class="header-anchor">#</a> wepy与mpvue对比分析</h1><h2 id="wepy的坑点"><a href="#wepy的坑点" aria-hidden="true" class="header-anchor">#</a> wepy的坑点</h2><h3 id="蛋疼的组件体系"><a href="#蛋疼的组件体系" aria-hidden="true" class="header-anchor">#</a> 蛋疼的组件体系</h3><p>wepy诞生之初小程序还没有原生自定义组件(虽然有了也未必怎样), 其组件体系是完全自己实现的, 组件wxml直接写到页面或父组件wxml, 绑定相应的数据和事件.
坑点如下:</p><ul><li>一个页面内声明为同名的组件是同一个实例, 共享一切. 意味着复用组件必须用不同的名字. 在实例对象下可以看到组件的变量名为<code>$$组件名$$变量名</code></li><li>循环渲染需要使用自造的repeat标签及其语法, 才能勉强做到将data分离, 但computed依然是所有同名组件实例共用的, 其值为最后一次计算结果.</li><li>因为组件根本就是嵌入父层统一渲染的, 所以css scope什么的, 自己通过类名去实现吧...</li><li>辣鸡的传参:
<ul><li>传参如果要穿对象只能直接传对象, 而不能传对象的子对象! 不能有任何运算包括点操作符和<code>[]</code>! 非循环渲染情况下还可以通过computed处理一下, 循环中这种情况基本无解, 只能再造一个新数组.</li><li>奇怪的绑定方式, <code>.sync</code>和<code>twoWay: true</code>, 很鸡肋的存在.</li><li>这里动态传参语法仿照vue使用:prop, 但由于并没有vue里最常用的:class和:style的实现, 所以其实我常常压根想不起来这里居然是用冒号.</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">mpvue的自定义组件</p><ul><li>也未使用原生自定义组件, 而是template(<a href="https://github.com/Meituan-Dianping/mpvue/issues/305" target="_blank" rel="noopener noreferrer">#305</a>), 所以也无法在组件外层绑定class或事件.</li><li>没有wepy的传参和computed这些问题. css scope也有.</li></ul></div><h3 id="事件体系"><a href="#事件体系" aria-hidden="true" class="header-anchor">#</a> 事件体系</h3><p>事件的模仿感觉比较糟糕, 魔改的痕迹明显.
坑点如下:</p><ul><li>挺不人性化的事件语法. 组件里emit出来的事件外部在捕获时一定要加.user修饰符. 事件既可以在构造器的events里面声明同名函数, 也可以在标签上绑定methods里声明的处理函数.</li><li>自定义参数十二分蛋疼. 记得有一次我要额外传个布尔值, 但怎么写都获取不到, 最后成功的语法好像是这样写的<code>@tap=&quot;handleTap(_, true)&quot;</code>. 没错, 虽然双大括号里理论上来说能写true和false, 但实践下来只能这样写能拿到正确的值. 只有别问我前面那个参数是个啥玩意, 我只知道那地方写什么都能获取到原事件. 按它官方手册上写的方式...反正我是没成功.</li><li>作者似乎对原生事件的捕获和阻止冒泡有啥<a href="https://tencent.github.io/wepy/document.html#/?id=%E7%BB%84%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0" target="_blank" rel="noopener noreferrer">误解</a>, .stop修饰符绑定catch事件, 作用的确是阻止冒泡, 但却和事件的捕获阶段capture没啥关系.</li></ul><div class="tip custom-block"><p class="custom-block-title">mpvue的事件</p><ul><li>没有wepy的这些坑, 一切都很vue.</li><li>强制使用@, 如果要使用原生事件, 则无法绑定处理函数, 只能使用诸如capture-catch:touchmove这样不需要处理的事件. 原因应该是, 事件是绑定在vnode上的, 中间有一层代理, 写在vue构造参数对象顶层的自定义方法其实会被丢弃掉, 而不会加入page或component的构造对象.</li></ul></div><div class="warning custom-block"><p class="custom-block-title">mpvue关于事件的一些下个版本会填掉的小坑(当前1.0.8)</p><ul><li>onShareAppMessage是每个page都有的, 写在源码里的无法去除.</li><li>暂时不支持capture捕获阶段的事件.</li></ul></div><h3 id="数据绑定"><a href="#数据绑定" aria-hidden="true" class="header-anchor">#</a> 数据绑定</h3><p>wepy的主打feature, 初衷是提供类似vue那样直接赋值来修改数据并更新视图, 避免原生提供的setData方式. 但很不幸...在异步流程里直接修改是无效的, 需要再手动调用<code>this.$apply()</code>以更新视图, 并且这样做会和setData起冲突, 使之前的修改无效.
据我分析是wepy在实例初始化的时候深拷贝了一份初始data对象, 合并到实例对象下, 使得可以通过<code>this.abc</code>直接去访问数据(而非<code>this.data.abc</code>), 然后实际维护的是这份data, 在生命周期或事件方法中修改data后会自动setData更新真正被使用的数据及视图. 但在异步流程中修改无效, 可见并未如vue一样采用defineProperty绑定set描述符的方式.</p><div class="tip custom-block"><p class="custom-block-title">mpvue的数据绑定</p><ul><li>理所应当没有问题.</li></ul></div><h3 id="问题根源"><a href="#问题根源" aria-hidden="true" class="header-anchor">#</a> 问题根源</h3><p><a href="https://github.com/Tencent/wepy/graphs/contributors" target="_blank" rel="noopener noreferrer">核心贡献者数量太少了</a>, 几乎就是个从零开始的个人项目. 2月6号至今只更新了一个补丁版本. 应该是在憋大招.</p><h2 id="除以上对比之外mpvue的可赞之处"><a href="#除以上对比之外mpvue的可赞之处" aria-hidden="true" class="header-anchor">#</a> 除以上对比之外mpvue的可赞之处</h2><ul><li>文档里详细说明了<strong>什么不能做</strong>, 各种地方都有<strong>踩坑注意</strong>, 这点特别暖! 因为是脱胎自vue, 部分功能受限于小程序无法实现, 都会有一一说明. 光从文档这点就比wepy不知道高到哪里去了.</li><li>app或页面参数options, 原生小程序只能从onLoad函数里获取, wepy对此未做工作. mpvue将其集成至根实例, 可以全局访问.</li><li>现成的ide插件支持, vue全家桶的snippet和提示已经相当成熟. 小程序因为只有中国人才用所以...</li><li>可以直接写html标签, 编译器会转译成对应小程序标签并带上类名, 这点对于小程序和web复用很重要.</li></ul><div class="tip custom-block"><p class="custom-block-title">标签转化</p><table><thead><tr><th>source</th><th>target</th></tr></thead><tbody><tr><td><code>&lt;div&gt;</code></td><td><code>&lt;view class=&quot;_div&quot;&gt;</code></td></tr><tr><td><code>&lt;span&gt;</code></td><td><code>&lt;label class=&quot;_span&quot;&gt;</code></td></tr><tr><td><code>&lt;a&gt;</code></td><td><code>&lt;navigator class=&quot;_a&quot;&gt;</code></td></tr><tr><td><code>&lt;view&gt;</code></td><td><code>&lt;view class=&quot;_view&quot;&gt;</code></td></tr><tr><td><code>&lt;custom-tag&gt;</code></td><td><code>&lt;custom-tag class=&quot;_custom-tag&quot;&gt;</code></td></tr></tbody></table></div><h2 id="小程序本身的无法避免的坑点"><a href="#小程序本身的无法避免的坑点" aria-hidden="true" class="header-anchor">#</a> 小程序本身的无法避免的坑点</h2><h3 id="开发者工具"><a href="#开发者工具" aria-hidden="true" class="header-anchor">#</a> 开发者工具</h3><p><strong>这个模拟器里最良心的可能是它的代码编辑器...</strong><br>
这年头还用nwjs的都应该看看隔壁微软vs code...</p><ul><li>不太稳定, 偶尔黑屏or白屏.</li><li>特定时间经常连不上wx自家的服务器.</li><li>莫名的模拟器专属真机没有的bug.</li></ul><h3 id="明明能做好但就是不做好气死你系列"><a href="#明明能做好但就是不做好气死你系列" aria-hidden="true" class="header-anchor">#</a> 明明能做好但就是不做好气死你系列</h3><ul><li>双大括号里只能进行简单运算, 不能调用正常函数, 想用函数? wxs了解一下?</li></ul><div class="tip custom-block"><p class="custom-block-title">wxs</p><p>这个东西是魔改阉割版es5. 不是跑在正常js环境里的, 目测是运行在原生渲染层, 因此和正常的js代码无法有任何互相作用.</p></div><ul><li>css选择器支持太孱弱了, 不支持属性选择器, 另外很多地方比如组件内都只能用简单的类选择器.</li><li>image组件并不是html标准的img标签, 它不是图片本身而是图片的容器, 并且有默认宽高.</li><li>不支持PATCH方法, 会静默失败. 用PUT替代.</li><li>标签里的属性明明可以写数组, 动态类名挺有用的, 但文档里只字不提.</li></ul><div class="tip custom-block"><p class="custom-block-title">标签属性里写数组</p><p>可以这样写,</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>static {{[isActive ? <span class="token punctuation">'</span>active<span class="token punctuation">'</span> : <span class="token punctuation">'</span><span class="token punctuation">'</span>, errorClass]}}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
</code></pre><p>甚至可以再套个[], 数组会被拍平.</p><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>static {{[[isActive ? <span class="token punctuation">'</span>active<span class="token punctuation">'</span> : <span class="token punctuation">'</span><span class="token punctuation">'</span>], errorClass]}}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="跨平台统一性并不完善"><a href="#跨平台统一性并不完善" aria-hidden="true" class="header-anchor">#</a> 跨平台统一性并不完善</h3><ul><li>ios上还是基于wkwebkit, 因此ios8还是个坑, css要加前缀, js要转es5.</li><li>原生控件的样式不统一, 如textarea的内边距, 如1px宽的线, 视觉差异显著.</li></ul><h3 id="一些小程序底层的问题"><a href="#一些小程序底层的问题" aria-hidden="true" class="header-anchor">#</a> 一些小程序底层的问题</h3><ul><li>map, canvas, video, textarea原生控件z-index高于一切, 甚至是调试器.</li><li>安卓上图片链接不支持//自适应协议写法.</li><li>体验版经常进去就无限转菊花, 开启调试模式就会好.</li><li>dom节点的增删改功能缺失, 查也很弱, 只提供一些几何信息.</li></ul><h2 id="迁移"><a href="#迁移" aria-hidden="true" class="header-anchor">#</a> 迁移</h2><h3 id="迁移工作"><a href="#迁移工作" aria-hidden="true" class="header-anchor">#</a> 迁移工作</h3><ul><li>模板语法改写. 标签就不替换了, 主要数据绑定, 样式绑定, 事件和指令语法.</li><li>状态管理要完全重写, 从wepy-redux到vuex.</li><li>mpvue完全基于webpack构建(vue-cli模板), 因此需要自己配置插件并安装依赖, 如less-loader.</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>wepy提供的wx api的promisify和request并发限制可以使用<a href="https://www.npmjs.com/package/common-mpvue" target="_blank" rel="noopener noreferrer">common-mpvue</a>插件实现.</p></div><ul><li>构造器参数对象结构微调. 方法全部写到methods里, 也不再有events属性.</li></ul><h3 id="迁移成本-米奇crm小程序"><a href="#迁移成本-米奇crm小程序" aria-hidden="true" class="header-anchor">#</a> 迁移成本(米奇CRM小程序)</h3><ul><li>重构周期. 保守预计五天.</li><li>测试负担. 除了米妮应该都需要测一遍，保守预计测试＋修bug需要三天.</li></ul></div><!----><!----></div></div></div>
    <script src="https://shawtung.github.io/mpvue-wepy-compare/assets/js/0.e6d0ac29.js" defer></script><script src="https://shawtung.github.io/mpvue-wepy-compare/assets/js/app.eedcdc70.js" defer></script>
  </body>
</html>
